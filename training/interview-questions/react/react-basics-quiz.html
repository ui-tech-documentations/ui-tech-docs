<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>React Quiz — React.js Interview Mock Test</title>
<meta name="description" content="React.js online quiz with 50 interview questions, explanations, and mock test practice for frontend developers." />
<meta name="keywords" content="React, React quiz, React.js interview questions, frontend interview, mock test, JavaScript frameworks" />
<meta name="author" content="Your Name" />
<meta property="og:title" content="React.js Online Quiz — Interview Mock Test" />
<meta property="og:description" content="Practice 50 React interview MCQs with detailed explanations. Perfect for frontend developers preparing for job interviews." />
<meta property="og:type" content="website" />
  <script src="https://unpkg.com/petite-vue" defer init></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .card { background: #fff; padding: 20px; border-radius: 12px; max-width: 700px; margin: auto; box-shadow: 0 2px 6px rgba(0,0,0,.1); }
    button { cursor: pointer; }
    .option { padding:12px; border:1px solid #ddd; border-radius:8px; margin-bottom:10px; text-align:left; width:100%; }
    .correct { background:#e8fbe8; border-color:#7bc67b; }
    .wrong { background:#ffe8e8; border-color:#e07a7a; }
    .grid { display:grid; grid-template-columns:repeat(5,1fr); gap:8px; }
  </style>
      <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
      <!-- <script src="https://cdn.tailwindcss.com"></script> -->
         <link rel="stylesheet" href="../../../assets/tailwind.css">
    <link rel="stylesheet" href="../../../assets/style.css">
</head>
<body class="bg-blue-200 py-4">
        <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="/" class="logo">UI Dev Docs</a>
            <div class="nav-links">
                <a href="/" class="nav-link">Home</a>
            </div>
        </div>
    </nav>
<div class="card mt-4" v-scope="quizApp()">
  <h2 class="font-bold text-blue-700 text-xl">React Js Quiz</h2>
  <p class="my-2">Question {{ index+1 }} / {{ questions.length }}</p>

  <template v-if="finished === false">
    <h3 class="my-2">{{ current.question }}</h3>

    <div>
      <button
        class="option"
        :class="selected === opt.label ? (opt.isCorrect ? 'correct' : 'wrong') : ''"
        v-for="opt in current.options"
        @click="select(opt)"
      >
        <strong>{{ opt.label }}.</strong> {{ opt.text }}
        <div v-if="selected === opt.label" style="margin-top:6px; font-size:14px;">
          <strong>{{ opt.isCorrect ? 'Right — ' : 'Wrong — ' }}</strong>{{ opt.note }}
        </div>
      </button>
    </div>

    <div style="display:flex; justify-content:space-between; margin-top:20px;">
      <!-- <button @click="prev" :disabled="index===0">Prev</button> -->
              <!-- Previous Button -->
        <button @click="prev" :disabled="index===0" class="group relative px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg overflow-hidden transition-all duration-300 hover:bg-blue-700 hover:shadow-lg hover:shadow-blue-500/30 active:scale-95">
            <!-- Animated Background -->
            <div class="absolute inset-0 bg-gradient-to-r from-blue-600 to-purple-600 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-500"></div>
            
            <!-- Content -->
            <div class="relative flex items-center gap-2">
                <i class="fas fa-chevron-left transition-transform duration-300 group-hover:translate-x-[-2px]"></i>
                <span>Previous</span>
            </div>
            
            <!-- Ripple Effect -->
            <div class="absolute inset-0 overflow-hidden rounded-lg">
                <div class="absolute inset-0 bg-white opacity-0 group-hover:opacity-10 transition-opacity duration-300"></div>
            </div>
        </button>
      <!-- <button @click="next">{{ index === questions.length-1 ? 'Finish' : 'Next' }}</button> -->
       <!-- Next Button -->
        <button @click="next" class="group relative px-6 py-3 bg-green-600 text-white font-semibold rounded-lg overflow-hidden transition-all duration-300 hover:bg-green-700 hover:shadow-lg hover:shadow-green-500/30 active:scale-95">
            <!-- Animated Background -->
            <div class="absolute inset-0 bg-gradient-to-r from-green-600 to-blue-600 translate-x-[100%] group-hover:translate-x-0 transition-transform duration-500"></div>
            
            <!-- Content -->
            <div class="relative flex items-center gap-2">
                <span>{{ index === questions.length-1 ? 'Finish' : 'Next' }}</span>
                <i class="fas fa-chevron-right transition-transform duration-300 group-hover:translate-x-[2px]"></i>
            </div>
            
            <!-- Ripple Effect -->
            <div class="absolute inset-0 overflow-hidden rounded-lg">
                <div class="absolute inset-0 bg-white opacity-0 group-hover:opacity-10 transition-opacity duration-300"></div>
            </div>
        </button>
    </div>  
    </div>
  </template>

  <template v-else>
    <h2>Your Score: {{ score }} / {{ questions.length }}</h2>
    <button @click="restart">Restart</button>
    <button @click="reviewMode = true" style="margin-left:10px;">Review Answers</button>

    <div v-if="reviewMode" style="margin-top:20px;">
      <h3>Review</h3>
      <div class="grid">
        <button
          v-for="(q, i) in questions"
          :class="answers[i]?.isCorrect ? 'correct' : 'wrong'"
          @click="jump(i)"
        >{{ i+1 }}</button>
      </div>
    </div>
  </template>
</div>

<script>
function quizApp() {
  return {
    index: 0,
    selected: null,
    finished: false,
    score: 0,
    reviewMode: false,
    answers: {},

questions: [
  {
    id: 1,
    question: "What is the primary purpose of React?",
    options: [
      { label: "A", text: "To style UI components", isCorrect: false, note: "React is not a styling library." },
      { label: "B", text: "To build user interfaces using a component-based approach", isCorrect: true, note: "React is a UI library based on components." },
      { label: "C", text: "To manage database queries", isCorrect: false, note: "React is frontend only." },
      { label: "D", text: "To compile JavaScript", isCorrect: false, note: "React does not compile JS." }
    ]
  },

  {
    id: 2,
    question: "What is JSX in React?",
    options: [
      { label: "A", text: "A CSS preprocessor", isCorrect: false, note: "JSX is not related to CSS." },
      { label: "B", text: "A syntax extension allowing HTML-like code in JS", isCorrect: true, note: "JSX makes UI declarative inside JS." },
      { label: "C", text: "A JSON format", isCorrect: false, note: "JSX is not JSON." },
      { label: "D", text: "A browser API", isCorrect: false, note: "JSX is compiled, not a browser feature." }
    ]
  },

  {
    id: 3,
    question: "Which hook is used to manage state in functional components?",
    options: [
      { label: "A", text: "useEffect", isCorrect: false, note: "useEffect is for side effects." },
      { label: "B", text: "useContext", isCorrect: false, note: "useContext accesses context, not state." },
      { label: "C", text: "useState", isCorrect: true, note: "useState adds state to function components." },
      { label: "D", text: "useMemo", isCorrect: false, note: "useMemo memoizes values." }
    ]
  },

  {
    id: 4,
    question: "Which hook handles side effects?",
    options: [
      { label: "A", text: "useEffect", isCorrect: true, note: "useEffect runs after render for side effects." },
      { label: "B", text: "useState", isCorrect: false, note: "useState is for state only." },
      { label: "C", text: "useReducer", isCorrect: false, note: "useReducer manages complex state." },
      { label: "D", text: "useRef", isCorrect: false, note: "useRef stores values that persist without re-rendering." }
    ]
  },

  {
    id: 5,
    question: "What is the virtual DOM?",
    options: [
      { label: "A", text: "A browser DOM replacement", isCorrect: false, note: "React does not replace DOM." },
      { label: "B", text: "A lightweight JS representation of the real DOM", isCorrect: true, note: "React diffs virtual DOM to update efficiently." },
      { label: "C", text: "A CSS rendering engine", isCorrect: false, note: "It’s not related to CSS." },
      { label: "D", text: "A JSON DOM structure", isCorrect: false, note: "Virtual DOM is not JSON." }
    ]
  },

  {
    id: 6,
    question: "What is props drilling?",
    options: [
      { label: "A", text: "Passing props deeply through many nested components", isCorrect: true, note: "Prop drilling happens when many layers must forward props." },
      { label: "B", text: "Passing props using Redux", isCorrect: false, note: "Redux avoids prop drilling." },
      { label: "C", text: "Passing only callback functions", isCorrect: false, note: "Drilling is about depth, not type." },
      { label: "D", text: "Using props inside CSS", isCorrect: false, note: "CSS is unrelated to props." }
    ]
  },

  {
    id: 7,
    question: "Which hook memoizes functions?",
    options: [
      { label: "A", text: "useMemo", isCorrect: false, note: "useMemo memoizes computed values." },
      { label: "B", text: "useCallback", isCorrect: true, note: "useCallback memoizes functions." },
      { label: "C", text: "useEffect", isCorrect: false, note: "useEffect handles side effects." },
      { label: "D", text: "useRef", isCorrect: false, note: "useRef stores mutable values." }
    ]
  },

  {
    id: 8,
    question: "Which hook memoizes computed values?",
    options: [
      { label: "A", text: "useCallback", isCorrect: false, note: "useCallback memoizes functions." },
      { label: "B", text: "useState", isCorrect: false, note: "useState stores state." },
      { label: "C", text: "useMemo", isCorrect: true, note: "useMemo memoizes expensive calculations." },
      { label: "D", text: "useEffect", isCorrect: false, note: "useEffect handles effects." }
    ]
  },

  {
    id: 9,
    question: "Which company maintains React?",
    options: [
      { label: "A", text: "Google", isCorrect: false, note: "Google maintains Angular, not React." },
      { label: "B", text: "Facebook (Meta)", isCorrect: true, note: "React is developed and maintained by Meta." },
      { label: "C", text: "Microsoft", isCorrect: false, note: "Microsoft maintains TypeScript." },
      { label: "D", text: "Amazon", isCorrect: false, note: "Amazon does not maintain React." }
    ]
  },

  {
    id: 10,
    question: "What is the correct way to pass props to a component?",
    options: [
      { label: "A", text: "<Component props='value' />", isCorrect: false, note: "Incorrect attribute syntax." },
      { label: "B", text: "<Component value={data} />", isCorrect: true, note: "Props are passed as attributes using {} for JS." },
      { label: "C", text: "Component(value)", isCorrect: false, note: "This is a function call, not JSX." },
      { label: "D", text: "prop(Component, value)", isCorrect: false, note: "prop() is not a React API." }
    ]
  },

  {
    id: 11,
    question: "What does lifting state up mean?",
    options: [
      { label: "A", text: "Using Redux instead of useState", isCorrect: false, note: "Unrelated to Redux." },
      { label: "B", text: "Moving shared state to a common parent component", isCorrect: true, note: "Shared state is moved up to reduce duplication." },
      { label: "C", text: "Using global variables", isCorrect: false, note: "React discourages global mutable state." },
      { label: "D", text: "Using useEffect for state", isCorrect: false, note: "useEffect is for effects." }
    ]
  },

  {
    id: 12,
    question: "What is React Fragment used for?",
    options: [
      { label: "A", text: "To conditionally render elements", isCorrect: false, note: "Fragments don’t handle conditions." },
      { label: "B", text: "To group elements without adding extra DOM nodes", isCorrect: true, note: "Fragments avoid unnecessary <div> wrappers." },
      { label: "C", text: "To create portals", isCorrect: false, note: "Portals use ReactDOM.createPortal." },
      { label: "D", text: "To handle errors", isCorrect: false, note: "Error boundaries handle errors." }
    ]
  },

  {
    id: 13,
    question: "What is the purpose of useRef?",
    options: [
      { label: "A", text: "To cause re-renders", isCorrect: false, note: "useRef does NOT re-render on change." },
      { label: "B", text: "To store mutable values that persist across renders", isCorrect: true, note: "useRef stores values without triggering re-renders." },
      { label: "C", text: "To memoize components", isCorrect: false, note: "useMemo or memo handle memoization." },
      { label: "D", text: "To change props dynamically", isCorrect: false, note: "Props cannot be changed." }
    ]
  },

  {
    id: 14,
    question: "What is React Router used for?",
    options: [
      { label: "A", text: "Global state management", isCorrect: false, note: "That's Redux or Context." },
      { label: "B", text: "Creating server APIs", isCorrect: false, note: "React Router does not handle servers." },
      { label: "C", text: "Client-side routing in React applications", isCorrect: true, note: "React Router manages navigation without page reloads." },
      { label: "D", text: "Handling CSS", isCorrect: false, note: "React Router does not touch styles." }
    ]
  },

  {
    id: 15,
    question: "Which method is used to create a React component class?",
    options: [
      { label: "A", text: "React.create()", isCorrect: false, note: "No such API exists." },
      { label: "B", text: "React.component()", isCorrect: false, note: "Incorrect name." },
      { label: "C", text: "class Component extends React.Component", isCorrect: true, note: "Class components inherit from React.Component." },
      { label: "D", text: "new React.Component()", isCorrect: false, note: "Component instances are created by React internally." }
    ]
  },

  {
    id: 16,
    question: "What is the purpose of default props?",
    options: [
      { label: "A", text: "To override required props", isCorrect: false, note: "Default props only provide fallback values." },
      { label: "B", text: "To provide fallback values when props are not passed", isCorrect: true, note: "defaultProps set default values." },
      { label: "C", text: "To validate props", isCorrect: false, note: "PropTypes validates props." },
      { label: "D", text: "To memoize props", isCorrect: false, note: "Memoization is done with memo()." }
    ]
  },

  {
    id: 17,
    question: "What hook is used to share logic across multiple components?",
    options: [
      { label: "A", text: "useShared", isCorrect: false, note: "No such hook." },
      { label: "B", text: "useEffect", isCorrect: false, note: "Handles effects only." },
      { label: "C", text: "Custom hooks", isCorrect: true, note: "Custom hooks allow sharing logic cleanly." },
      { label: "D", text: "useRef", isCorrect: false, note: "Stores refs only." }
    ]
  },

  {
    id: 18,
    question: "What does React.memo() do?",
    options: [
      { label: "A", text: "Stores state", isCorrect: false, note: "Use useState." },
      { label: "B", text: "Memoizes entire components to avoid unnecessary re-renders", isCorrect: true, note: "memo() skips rendering if props haven't changed." },
      { label: "C", text: "Cleans up side effects", isCorrect: false, note: "Cleanup happens inside useEffect." },
      { label: "D", text: "Handles errors", isCorrect: false, note: "Error boundaries handle errors." }
    ]
  },

  {
    id: 19,
    question: "What is an error boundary?",
    options: [
      { label: "A", text: "A component that catches JavaScript errors in child components", isCorrect: true, note: "Error boundaries catch runtime rendering errors." },
      { label: "B", text: "A React hook", isCorrect: false, note: "Error boundaries must be class components." },
      { label: "C", text: "A function for debugging", isCorrect: false, note: "Not related to debugging tools." },
      { label: "D", text: "A CSS property", isCorrect: false, note: "Not related to CSS." }
    ]
  },

  {
    id: 20,
    question: "Which method renders React elements into the DOM?",
    options: [
      { label: "A", text: "React.mount()", isCorrect: false, note: "Not a valid API." },
      { label: "B", text: "ReactDOM.render()", isCorrect: true, note: "render() mounts elements into the DOM." },
      { label: "C", text: "React.render()", isCorrect: false, note: "Not a valid method." },
      { label: "D", text: "ReactDOM.mount()", isCorrect: false, note: "Not an existing API." }
    ]
  },

  {
    id: 21,
    question: "What is the purpose of React keys?",
    options: [
      { label: "A", text: "To style elements", isCorrect: false, note: "Keys do not affect styling." },
      { label: "B", text: "To identify elements uniquely during reconciliation", isCorrect: true, note: "Keys help React track items efficiently." },
      { label: "C", text: "To bind events", isCorrect: false, note: "Events are separate." },
      { label: "D", text: "To handle routing", isCorrect: false, note: "Routing uses React Router." }
    ]
  },

  {
    id: 22,
    question: "What does useReducer do?",
    options: [
      { label: "A", text: "Handles side effects", isCorrect: false, note: "useEffect handles effects." },
      { label: "B", text: "Replaces useState for complex state logic", isCorrect: true, note: "useReducer works well for complex state and actions." },
      { label: "C", text: "Validates props", isCorrect: false, note: "PropTypes validates props." },
      { label: "D", text: "Optimizes rendering", isCorrect: false, note: "Memo handles optimization." }
    ]
  },

  {
    id: 23,
    question: "What does React.StrictMode do?",
    options: [
      { label: "A", text: "Enables runtime performance optimization", isCorrect: false, note: "StrictMode is not a performance feature." },
      { label: "B", text: "Highlights potential problems in an application", isCorrect: true, note: "StrictMode detects unsafe lifecycle usage and warnings." },
      { label: "C", text: "Compiles JavaScript", isCorrect: false, note: "Bundlers do compilation." },
      { label: "D", text: "Handles routing", isCorrect: false, note: "Routing is separate." }
    ]
  },

  {
    id: 24,
    question: "Which hook gives access to context values?",
    options: [
      { label: "A", text: "useState", isCorrect: false, note: "useState stores state." },
      { label: "B", text: "useRef", isCorrect: false, note: "useRef stores refs." },
      { label: "C", text: "useContext", isCorrect: true, note: "useContext returns current context value." },
      { label: "D", text: "useMemo", isCorrect: false, note: "Memoizes values." }
    ]
  },

  {
    id: 25,
    question: "Which hook runs only once on component mount (if dependencies are empty)?",
    options: [
      { label: "A", text: "useEffect(() => {}, [])", isCorrect: true, note: "Empty array → run once on mount." },
      { label: "B", text: "useEffect(() => {})", isCorrect: false, note: "Runs after every render." },
      { label: "C", text: "useState()", isCorrect: false, note: "Creates state only." },
      { label: "D", text: "useRef()", isCorrect: false, note: "Stores refs only." }
    ]
  },

  {
    id: 26,
    question: "What is a pure component?",
    options: [
      { label: "A", text: "A component without JSX", isCorrect: false, note: "JSX does not define purity." },
      { label: "B", text: "A component that re-renders only if props or state change", isCorrect: true, note: "PureComponent does shallow comparison." },
      { label: "C", text: "A component with no state", isCorrect: false, note: "Stateless is not the same as pure." },
      { label: "D", text: "A component with only functions", isCorrect: false, note: "Unrelated to purity." }
    ]
  },

  {
    id: 27,
    question: "What is PropTypes used for?",
    options: [
      { label: "A", text: "Styling components", isCorrect: false, note: "PropTypes doesn’t style." },
      { label: "B", text: "Validating component props", isCorrect: true, note: "PropTypes validates types at runtime." },
      { label: "C", text: "Optimizing components", isCorrect: false, note: "Memo optimizes." },
      { label: "D", text: "Creating custom hooks", isCorrect: false, note: "Hooks are unrelated." }
    ]
  },

  {
    id: 28,
    question: "Which function creates a context?",
    options: [
      { label: "A", text: "React.createState()", isCorrect: false, note: "No such API." },
      { label: "B", text: "React.createContext()", isCorrect: true, note: "Creates a new context." },
      { label: "C", text: "React.context()", isCorrect: false, note: "Incorrect name." },
      { label: "D", text: "React.provider()", isCorrect: false, note: "Provider is a component, not a method." }
    ]
  },

  {
    id: 29,
    question: "What is the purpose of useLayoutEffect?",
    options: [
      { label: "A", text: "Runs after paint", isCorrect: false, note: "useEffect runs after paint." },
      { label: "B", text: "Runs synchronously before paint", isCorrect: true, note: "useLayoutEffect blocks painting until complete." },
      { label: "C", text: "Updates state", isCorrect: false, note: "useState updates state." },
      { label: "D", text: "Memoizes values", isCorrect: false, note: "useMemo does this." }
    ]
  },

  {
    id: 30,
    question: "What is React Portal used for?",
    options: [
      { label: "A", text: "Render children outside the parent DOM hierarchy", isCorrect: true, note: "Portals let you place components anywhere in DOM." },
      { label: "B", text: "Handle routing", isCorrect: false, note: "Routing uses React Router." },
      { label: "C", text: "Optimize performance", isCorrect: false, note: "Portals do not optimize performance." },
      { label: "D", text: "Create fragments", isCorrect: false, note: "Fragments use <>...</>." }
    ]
  },

  {
    id: 31,
    question: "What causes React to re-render a component?",
    options: [
      { label: "A", text: "Console logs inside the component", isCorrect: false, note: "Logs do not trigger renders." },
      { label: "B", text: "Changes to state or props", isCorrect: true, note: "React re-renders on state/prop changes." },
      { label: "C", text: "CSS changes", isCorrect: false, note: "CSS does not trigger React renders." },
      { label: "D", text: "Static variable changes", isCorrect: false, note: "React doesn't track non-state variables." }
    ]
  },

  {
    id: 32,
    question: "What is the purpose of React.StrictMode?",
    options: [
      { label: "A", text: "Prevents production errors", isCorrect: false, note: "Errors can still occur." },
      { label: "B", text: "Identifies unsafe or deprecated lifecycle methods", isCorrect: true, note: "StrictMode highlights potential issues." },
      { label: "C", text: "Improves performance", isCorrect: false, note: "StrictMode may cause double renders in dev." },
      { label: "D", text: "Applies strict CSS rules", isCorrect: false, note: "CSS unrelated." }
    ]
  },

  {
    id: 33,
    question: "How do you prevent a child component from re-rendering?",
    options: [
      { label: "A", text: "Using React.memo()", isCorrect: true, note: "memo() skips re-renders unless props change." },
      { label: "B", text: "Using useEffect", isCorrect: false, note: "useEffect does not prevent rendering." },
      { label: "C", text: "Using PropTypes", isCorrect: false, note: "PropTypes are for validation." },
      { label: "D", text: "Using useReducer", isCorrect: false, note: "useReducer manages state only." }
    ]
  },

  {
    id: 34,
    question: "How do you update state based on previous state?",
    options: [
      { label: "A", text: "setState(newState)", isCorrect: false, note: "This ignores previous state." },
      { label: "B", text: "setState(prev => newValue)", isCorrect: true, note: "Functional updates correctly use previous state." },
      { label: "C", text: "state = newState", isCorrect: false, note: "Never mutate state directly." },
      { label: "D", text: "useEffect(() => setState())", isCorrect: false, note: "Side effects should not be used unnecessarily." }
    ]
  },

  {
    id: 35,
    question: "What is a controlled component?",
    options: [
      { label: "A", text: "A component without state", isCorrect: false, note: "Controlled components use state heavily." },
      { label: "B", text: "A form input controlled by React state", isCorrect: true, note: "Value is controlled by state, not DOM." },
      { label: "C", text: "A parent-only component", isCorrect: false, note: "Nothing to do with parents." },
      { label: "D", text: "A component inside a HOC", isCorrect: false, note: "Unrelated concept." }
    ]
  },

  {
    id: 36,
    question: "What is an uncontrolled component?",
    options: [
      { label: "A", text: "A form input controlled directly by the DOM", isCorrect: true, note: "Value comes from DOM using refs." },
      { label: "B", text: "A component with no props", isCorrect: false, note: "Props are unrelated." },
      { label: "C", text: "A component without events", isCorrect: false, note: "Events unrelated to control." },
      { label: "D", text: "A stateless component", isCorrect: false, note: "Stateless ≠ uncontrolled." }
    ]
  },

  {
    id: 37,
    question: "How do you stop event bubbling in React?",
    options: [
      { label: "A", text: "event.preventDefault()", isCorrect: false, note: "Prevents default, not bubbling." },
      { label: "B", text: "event.stopPropagation()", isCorrect: true, note: "stopPropagation stops bubbling." },
      { label: "C", text: "return false", isCorrect: false, note: "Does NOT work in React." },
      { label: "D", text: "event.pause()", isCorrect: false, note: "pause() does not exist." }
    ]
  },

  {
    id: 38,
    question: "What is ReactDOM.createPortal used for?",
    options: [
      { label: "A", text: "To create React components", isCorrect: false, note: "Components are created with functions/classes." },
      { label: "B", text: "To render children into a DOM node outside their parent hierarchy", isCorrect: true, note: "Used for modals, tooltips, overlays." },
      { label: "C", text: "For routing", isCorrect: false, note: "Routing uses React Router." },
      { label: "D", text: "For performance optimization", isCorrect: false, note: "Portals do not optimize performance." }
    ]
  },

  {
    id: 39,
    question: "Which hook is used for performance optimization in components?",
    options: [
      { label: "A", text: "useEffect", isCorrect: false, note: "Handles effects only." },
      { label: "B", text: "useState", isCorrect: false, note: "Stores state only." },
      { label: "C", text: "useMemo", isCorrect: true, note: "useMemo memoizes expensive calculations." },
      { label: "D", text: "useRef", isCorrect: false, note: "Stores mutable values." }
    ]
  },

  {
    id: 40,
    question: "What is React.lazy used for?",
    options: [
      { label: "A", text: "Performance profiling", isCorrect: false, note: "Profiler is separate." },
      { label: "B", text: "Code splitting and lazy loading components", isCorrect: true, note: "React.lazy loads components only when needed." },
      { label: "C", text: "Memoizing components", isCorrect: false, note: "memo() memoizes components." },
      { label: "D", text: "Creating custom hooks", isCorrect: false, note: "Lazy loads components only." }
    ]
  },

  {
    id: 41,
    question: "What component is required to wrap lazy-loaded components?",
    options: [
      { label: "A", text: "<Router>", isCorrect: false, note: "Router handles navigation." },
      { label: "B", text: "<Provider>", isCorrect: false, note: "Provider handles context." },
      { label: "C", text: "<Suspense>", isCorrect: true, note: "Suspense shows fallback content while loading." },
      { label: "D", text: "<Wrapper>", isCorrect: false, note: "No such component." }
    ]
  },

  {
    id: 42,
    question: "What is the purpose of React.StrictMode?",
    options: [
      { label: "A", text: "Production debugging", isCorrect: false, note: "StrictMode is dev-only." },
      { label: "B", text: "Highlight unsafe lifecycle methods", isCorrect: true, note: "StrictMode helps detect issues early." },
      { label: "C", text: "Stop re-renders", isCorrect: false, note: "It may trigger extra renders." },
      { label: "D", text: "Enable portals", isCorrect: false, note: "Portals unrelated." }
    ]
  },

  {
    id: 43,
    question: "Which hook tracks the width and height of a DOM element?",
    options: [
      { label: "A", text: "useState", isCorrect: false, note: "Tracks state only." },
      { label: "B", text: "useEffect", isCorrect: false, note: "Not specialized for measuring elements." },
      { label: "C", text: "useLayoutEffect", isCorrect: true, note: "Used for DOM measurements before paint." },
      { label: "D", text: "useCallback", isCorrect: false, note: "Memoizes functions." }
    ]
  },

  {
    id: 44,
    question: "How do you import a component in React?",
    options: [
      { label: "A", text: "load Component from 'react'", isCorrect: false, note: "Invalid syntax." },
      { label: "B", text: "import Component from './Component'", isCorrect: true, note: "Default import syntax is correct." },
      { label: "C", text: "include('./Component')", isCorrect: false, note: "Not JavaScript syntax." },
      { label: "D", text: "require.component()", isCorrect: false, note: "Invalid method." }
    ]
  },

  {
    id: 45,
    question: "How do you conditionally render elements in React?",
    options: [
      { label: "A", text: "v-if", isCorrect: false, note: "v-if is Vue syntax." },
      { label: "B", text: "{ condition && <Element /> }", isCorrect: true, note: "Logical AND is common for conditional rendering." },
      { label: "C", text: "if in JSX tags", isCorrect: false, note: "JSX cannot directly use if inside tags." },
      { label: "D", text: "<Element if={condition}>", isCorrect: false, note: "Not valid React syntax." }
    ]
  },

  {
    id: 46,
    question: "What is reconciliation in React?",
    options: [
      { label: "A", text: "Updating the real DOM directly", isCorrect: false, note: "React avoids direct DOM manipulation." },
      { label: "B", text: "Comparing virtual DOM trees to update UI efficiently", isCorrect: true, note: "React diffs old and new VDOM to update minimal DOM." },
      { label: "C", text: "Syncing state and props", isCorrect: false, note: "Not related to reconciliation." },
      { label: "D", text: "Managing routes", isCorrect: false, note: "Routing unrelated." }
    ]
  },

  {
    id: 47,
    question: "Which lifecycle is used to fetch data in class components?",
    options: [
      { label: "A", text: "componentDidMount", isCorrect: true, note: "Runs once after first render → safe to fetch data." },
      { label: "B", text: "constructor", isCorrect: false, note: "constructor should not contain side effects." },
      { label: "C", text: "render", isCorrect: false, note: "render must be pure." },
      { label: "D", text: "componentWillUnmount", isCorrect: false, note: "Used for cleanup." }
    ]
  },

  {
    id: 48,
    question: "What is hydration in React?",
    options: [
      { label: "A", text: "Styling server-rendered HTML", isCorrect: false, note: "Unrelated to styling." },
      { label: "B", text: "Attaching event listeners to HTML generated by SSR", isCorrect: true, note: "Hydration turns static SSR HTML interactive." },
      { label: "C", text: "Refetching API data", isCorrect: false, note: "Hydration does not fetch data." },
      { label: "D", text: "Re-rendering components repeatedly", isCorrect: false, note: "Re-renders are unrelated." }
    ]
  },

  {
    id: 49,
    question: "What is the purpose of useId()?",
    options: [
      { label: "A", text: "Generate unique IDs for accessibility and keys", isCorrect: true, note: "useId creates stable unique IDs." },
      { label: "B", text: "Generate keys for arrays only", isCorrect: false, note: "Keys should not be created dynamically in most cases." },
      { label: "C", text: "Track component mount count", isCorrect: false, note: "Unrelated to counting." },
      { label: "D", text: "Optimize performance", isCorrect: false, note: "It's a utility hook." }
    ]
  },

  {
    id: 50,
    question: "What is the purpose of forwardRef?",
    options: [
      { label: "A", text: "To memoize a component", isCorrect: false, note: "memo() does this." },
      { label: "B", text: "To pass refs to child components", isCorrect: true, note: "forwardRef allows parent to access child's DOM node or ref." },
      { label: "C", text: "To create portals", isCorrect: false, note: "Unrelated." },
      { label: "D", text: "To handle effects", isCorrect: false, note: "Effects use useEffect." }
    ]
  }
],

    get current() {
      return this.questions[this.index]
    },

    select(opt) {
      this.selected = opt.label
      if (!this.answers[this.index]) {
        this.answers[this.index] = { label: opt.label, isCorrect: opt.isCorrect }
        if (opt.isCorrect) this.score++
      } else {
        const prev = this.answers[this.index]
        if (prev.isCorrect && !opt.isCorrect) this.score--
        if (!prev.isCorrect && opt.isCorrect) this.score++
        this.answers[this.index] = { label: opt.label, isCorrect: opt.isCorrect }
      }
    },

    next() {
      if (this.index < this.questions.length - 1) {
        this.index++
        this.selected = this.answers[this.index]?.label || null
        console.log(this.index);
      } else {
        this.finished = true
      }
    },

    prev() {
      if (this.index > 0) {
        this.index--
        this.selected = this.answers[this.index]?.label || null
      }
    },

    restart() {
      this.index = 0
      this.selected = null
      this.finished = false
      this.score = 0
      this.answers = {}
      this.reviewMode = false
    },

    jump(i) {
      this.index = i
      this.selected = this.answers[i]?.label || null
      this.reviewMode = false
    }
  }
}
</script>

</body>
</html>
